{"meta":{"title":"Miss Ren's BLOG","subtitle":"","description":"","author":"renwanjun","url":"http://renwanjun.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-08-09T03:39:58.000Z","updated":"2021-08-09T03:39:58.476Z","comments":true,"path":"tags/index.html","permalink":"http://renwanjun.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-09T03:40:07.000Z","updated":"2021-08-09T03:40:07.849Z","comments":true,"path":"categories/index.html","permalink":"http://renwanjun.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-08-09T01:50:00.583Z","updated":"2021-08-09T01:50:00.583Z","comments":true,"path":"2021/08/09/hello-world/","link":"","permalink":"http://renwanjun.github.io/2021/08/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"es6-generator","slug":"es6-generator","date":"2021-02-26T10:39:18.000Z","updated":"2021-02-26T10:39:18.000Z","comments":true,"path":"2021/02/26/es6-generator/","link":"","permalink":"http://renwanjun.github.io/2021/02/26/es6-generator/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Promise对象","slug":"es6-promise","date":"2021-02-26T10:10:07.000Z","updated":"2021-02-26T10:35:00.000Z","comments":true,"path":"2021/02/26/es6-promise/","link":"","permalink":"http://renwanjun.github.io/2021/02/26/es6-promise/","excerpt":"","text":"dddweishenmeichulaine","categories":[],"tags":[]},{"title":"browser-xnyh","slug":"browser-xnyh","date":"2020-04-21T02:49:28.000Z","updated":"2020-04-21T02:50:43.000Z","comments":true,"path":"2020/04/21/browser-xnyh/","link":"","permalink":"http://renwanjun.github.io/2020/04/21/browser-xnyh/","excerpt":"","text":"https://github.com/LuckyWinty/blog/blob/master/markdown/perf/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E5%8F%8A%E4%B8%8A%E6%8A%A5%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3.md https://github.com/LuckyWinty/blog/blob/master/markdown/perf/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%88%A9%E7%94%A8Chrome%20Dev%20Tools%20%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.md","categories":[],"tags":[]},{"title":"H5原生拖放","slug":"h5-native-drag-drop","date":"2020-04-17T04:37:02.000Z","updated":"2020-04-17T09:25:46.000Z","comments":true,"path":"2020/04/17/h5-native-drag-drop/","link":"","permalink":"http://renwanjun.github.io/2020/04/17/h5-native-drag-drop/","excerpt":"","text":"原生拖放的事件 ie4:最早在网页中引入JavaScript拖放功能。当时在网页中只有两种对象可以拖放： 图像和某些文本。唯一有效的放置目标是文本框 ie5：拖放功能得到扩展，添加了新的事件，而且几乎网页中的任何元素都可以作为放置目标 ie5.5:让网页中的任何元素都可以拖放 HTML5以IE的实例为基础制定了拖放的规范，Firefox3.5、Safari4+和Chrome也根据HTML5规范实现了原生了拖放功能。可以在框架间、窗口见，甚至在应用间拖放元素。 拖放事件拖动某元素时，将依次触发下列事件： dragstart drag dragend 当某个元素被拖动到一个有效的放置目标上时，下列事件会一次发生： dragenter dragover dragleave or drop 可拖动draggable默认情况下，图像、链接和文本是可以拖动的。文本只有在被选中的情况下才能被拖动，而图像和链接在任何时候都可以拖动。让其它元素可拖动，H5为所有元素规定了一个draggable属性，表示元素是否可以拖动。要想让其它元素可拖动，或者让图像或链接不能土洞，都可以设置这个属性。例如： &lt;!-- 让这个图像不可拖动 --&gt; &lt;img alt=&quot;Smiley face&quot; draggable=&quot;false&quot; src=&quot;smile.gif&quot;&gt; &lt;!-- 让这个元素可以拖动 --&gt; &lt;div draggable=&quot;true&quot;&gt;...&lt;div&gt; 兼容性 为了让FireFox支持拖动属性，还必须添加一个obdragstart事件处理程序，并在dataTransfer对象中保存一些信息。 在IE9及更早版本中，通过mousedown事件处理程序调用dragDrop()能够让任何元素可拖动。 而在Safari4及之前版本中，必须额外给相应元素设置CSS样式-khtml-user-drag:element. 自定义放置目标虽然所有元素都支持放置目标事件，但这些元素默认是不允许放置的。如果拖动元素经过不允许放置的元素，无论用户如何操作都不会发生drop事件。不过可以将任何元素变成有效的放置目标，方法是重写dragenter和dragover事件的默认行为。例如，假设又一个ID为“droptarget”的&lt;div&gt;元素,可以用如下代码将它变成一个放置目标： var droptarget=document.getElementBtId(&#39;droptarget&#39;); droptarget.addEventListener(&#39;dragenter&#39;,function(event)&#123; event.preventDefault() &#125;) droptarget.addEventListener(&#39;dragover&#39;,function(event)&#123; event.preventDefault() &#125;) FireFox3.5+中，放置事件（drop）的默认行为是打开被放到拖置目标上的URL。换句话说，如果是把图像拖放到放置目标上，页面就会转向图像文件；而如果是把文本拖放到放置目标上，则会导致无效的URL错误。因此，为了让FireFox支持正常的拖放，还需要取消drop事件的默认行为，阻止它打开URL。 dataTransfer对象getData()和setData()方法 getData() setData() 1// 设置和接受文本数据 dropEffect和effectAllowed属性 dropEffect属性可以知道被拖动的元素能够执行哪种放置行为。 “none” “move” “copy” “link” 要使用dropEffect属性，必须在ondragenter事件处理程序中针对放置目标来设置。dropEffect属性只有搭配effectAllowed属性才有用。effectAllowed属性表示允许拖动元素的哪种dropEffect. 必须在ondragstart事件处理程序中设置effectAllowed","categories":[],"tags":[]},{"title":"browser-garbage-collection","slug":"browser-garbage-collection","date":"2020-04-17T03:15:19.000Z","updated":"2020-04-17T03:21:17.000Z","comments":true,"path":"2020/04/17/browser-garbage-collection/","link":"","permalink":"http://renwanjun.github.io/2020/04/17/browser-garbage-collection/","excerpt":"","text":"浏览器垃圾回收机制引用计数算法标记清楚算法 将不再使用的对象——标记为无法到达的对象 内存泄漏常见的内存泄漏和DOM引用有关 参考链接","categories":[],"tags":[]},{"title":"焦点管理","slug":"dom-focus","date":"2020-04-03T10:49:17.000Z","updated":"2020-04-03T11:04:01.000Z","comments":true,"path":"2020/04/03/dom-focus/","link":"","permalink":"http://renwanjun.github.io/2020/04/03/dom-focus/","excerpt":"","text":"document.activeElement 这个属性始终会引用DOM中当前获得了焦点的元素。 元素获得页面的焦点的方式 页面加载默认情况下，当页面刚刚加载完成时，document.activeElement中保存的是document.body元素的引用。在文档加载期间，document.activeElementd的值是null。 用户输入通常是通过按Tab键 代码中调用focus()方法123var button=document.getElementById(&#x27;reset&#x27;);button.focus();document.activeElement===button; // true document.hasFocus()用于确定文档是否获得了焦点。通过检测文档是否获得了焦点，可以知道用户是否正在与页面交互。","categories":[],"tags":[]},{"title":"dom-summary","slug":"dom-summary","date":"2020-04-03T10:42:15.000Z","updated":"2020-04-04T03:02:59.000Z","comments":true,"path":"2020/04/03/dom-summary/","link":"","permalink":"http://renwanjun.github.io/2020/04/03/dom-summary/","excerpt":"","text":"document部分对html节点的直接引用 document.head 引用文档的&lt;head&gt;元素 1var head=document.head || document.getElementByTagName(&#x27;head&#x27;)[0] document.body document.doctype document.forms document.images document.iframes document.activeElement HTML5新增 这个属性始终会引用DOM中当前获得了焦点的元素 状态 document.compatMode 判断渲染页面的模式，返回值：“CSS1Compat”——标准模式“BackCompat”——混杂模式","categories":[],"tags":[]},{"title":"DOM 节点层次","slug":"dom-tree","date":"2020-04-01T05:16:51.000Z","updated":"2020-04-03T10:42:05.000Z","comments":true,"path":"2020/04/01/dom-tree/","link":"","permalink":"http://renwanjun.github.io/2020/04/01/dom-tree/","excerpt":"","text":"elem.children和elem.childNodes的区别","categories":[],"tags":[]},{"title":"前端面试题汇总","slug":"web-interview-subjects","date":"2020-03-16T08:49:09.000Z","updated":"2020-03-16T08:54:24.000Z","comments":true,"path":"2020/03/16/web-interview-subjects/","link":"","permalink":"http://renwanjun.github.io/2020/03/16/web-interview-subjects/","excerpt":"","text":"JavaScript 基础手写题目","categories":[],"tags":[]},{"title":"html-rendering","slug":"html-rendering","date":"2020-03-16T05:02:20.000Z","updated":"2020-03-16T08:47:08.000Z","comments":true,"path":"2020/03/16/html-rendering/","link":"","permalink":"http://renwanjun.github.io/2020/03/16/html-rendering/","excerpt":"","text":"浏览器渲染基本流程GUI渲染进程1.解析html文本并构建DOM tree2.解析CSS样式表并构建CSSOM tree3.根据DOM tree和CSSOM tree构建Render tree4.根据Render tree信息进行布局处理(layout)5.对页面元素进行绘制(painting) 解析(Parsing)解析的过程分为两个步骤：词法分析（Lexical Analysis）和语法分析(Syntax Analysis)。词法分析负责将输入内容分解成一个个有效标记；而语法分析负责根据语言的语法规则分析文档的结构，从而构建解析树(Parse Tree)。通过词法分析可以将无关的字符（比如空格和换行符）分离出来。 处理脚本和样式表的顺序当浏览器碰到script脚本的时候 1. 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 2. 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 3. 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 脚本阻塞CSS的阻塞","categories":[],"tags":[]},{"title":"JavaScript事件循环机制","slug":"js-event-loop","date":"2020-03-12T12:53:23.000Z","updated":"2020-04-17T03:14:18.000Z","comments":true,"path":"2020/03/12/js-event-loop/","link":"","permalink":"http://renwanjun.github.io/2020/03/12/js-event-loop/","excerpt":"","text":"前言希望通过这篇文章，了解到Event Loop到底是一种什么机制，浏览器和NodeJS的Event Loop又有什么区别。 从浏览器多进程到JS单线程，再到JS引擎的运行机制系统。 并行处理在理解进程和线程之前，首先需要了解的就是并行处理，理解了并行处理之后，再理解进程和线程就会容易很多。所谓并行处理就是说计算机在同一个时刻处理多个任务，比如计算下面三个表达式的值，并显示出结果： A = 1 + 1 B = 2 + 2 C = 3 + 3 按照正常的执行流程，下面的流程会这样执行： * 任务 1 是计算 A=1+1； * 任务 2 是计算 B=2+2； * 任务 3 是计算 C=3+3； * 任务 4 是显示最后计算的结果。 上面的执行流程就是单线程处理。如果使用多线程处理，我们只需要分2步即可完成上面的任务，第1步：使用三个线程同时执行前三个任务；第2步，再执行第四个显示任务。 通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。 因此，使用多线程并行处理能大大提升性能。 进程和线程多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来管理和启动的。 进程一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。进程是cpu资源分配的最小单位（系统会给他分配内存）。 线程线程是依附于进程的，而进程中使用多线程来并行处理能提升元算效率。 浏览器是多进程的浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了。（所以每一个Tab标签对应一个进程并不一定是绝对的） 浏览器包含哪些进程知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程） 1.Browser进程：浏览器的主进程（负责协调、主控），每个浏览器只有一个。作用有负责浏览器界面显示，与用户交互，如前进，后退等。负责各个页面的管理，创建和销毁其他进程。将Renderer进程得到的内存中的Bitmap绘制到用户界面上，网络资源的管理，下载等2.第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建3.GPU进程：最多一个，用于3D绘制等4.浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等 强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程） 浏览器的渲染进程是多线程的对于普通的前端来说，最需要要了解的就是渲染进程 1.GUI渲染进程 负责渲染浏览器界面，解析HTML、CSS，构建DOM树和RenderObject树，布局和绘制等。并且当界面需要重绘(Repainting)或由于某种操作引发回流(Reflow)时，该线程就会执行。注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 2.JS引擎线程也称为JS内核，负责处理Javascript脚本程序（例如V8引擎）。JS引擎线程负责解析Javascript脚本，运行代码。JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序。同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 3.事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中。当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 4.定时触发器线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确。因此通过单独线程来计时并触发定时，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行。 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 5.异步HTTP请求线程XMLHttpRequest在连接后是通过浏览器新开一个线程请求，在检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 浏览器多进程的优势TODOBrowser进程和浏览器内核（Render进程）的通信过程打开任务管理器并打开一个浏览器，可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程），然后在这前提下，看下整个的过程：(简化了很多)Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通RendererHost接口传递给Render进程。 Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染。 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘。 最后Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来。 浏览器内核中线程之间的关系GUI渲染线程与JS引擎线程互斥JS阻塞页面加载 宏任务和微任务https://www.jianshu.com/p/f1e5ad3b4afb","categories":[],"tags":[]},{"title":"NPM常用命令","slug":"npm-command","date":"2020-03-02T07:25:31.000Z","updated":"2020-03-12T12:52:57.000Z","comments":true,"path":"2020/03/02/npm-command/","link":"","permalink":"http://renwanjun.github.io/2020/03/02/npm-command/","excerpt":"","text":"基本命令查看$ npm ls [过滤条件] 使用这个命令查看所有发型包列表和它们的版本，过滤条件可选，或者几个过滤条件结合查看。 $ npm ls installed // 查看已经安装的Node包 $ npm ls stable // 产看所有稳定版的发型包 $ npm ls installed stable //结合过滤条件查看 $ npm ls fug //按照模块名称查看 $ npm ls @1.0 安装$ npm install package[@过滤条件] 使用这个命令可以安装一个指定的包 $ npm install 包的名称 //安装指定包 $ npm install 包的名称@版本号 //安装指定版本的 包 $ npm install 包的名称@&gt;=版本号 //结合版本号和范围安装 删除包$ npm rm sax //删除包的所有版本 $ npm rm -g express //删除以全局模式安装的包 查看包的信息$ npm view connect $ npm view connect@1.0.3 //查看特定版本的包的信息 package.json文件版本号主版本.次版本.补丁版本号例如 1.12.3既然补丁版本号仅仅是修复一些程序bug,指定主版本号和次版本号，不限定补丁版本号就是一个常用的方法。如：1.23.x","categories":[{"name":"Tool","slug":"Tool","permalink":"http://renwanjun.github.io/categories/Tool/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://renwanjun.github.io/tags/npm/"},{"name":"command","slug":"command","permalink":"http://renwanjun.github.io/tags/command/"}]},{"title":"闭包","slug":"js-closure","date":"2020-03-02T04:49:15.000Z","updated":"2020-03-16T09:11:03.000Z","comments":true,"path":"2020/03/02/js-closure/","link":"","permalink":"http://renwanjun.github.io/2020/03/02/js-closure/","excerpt":"","text":"执行环境和作用域回顾作用域链的概念：当某个函数被调用时，会创建一个执行环境及相应的作用域链，然后使用arguments和其它命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，直到作为作用域链终点的全局执行环境。 执行环境和变量对象每一个执行环境都有与之相对应的变量对象，全局环境的变量对象始终存在，而局部环境的变量对象在执行退出后就会自动销毁。 活动对象就函数而言，在函数执行的时候存在； 显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际的包含对象。 this对象是在运行时基于函数的执行环境绑定的；在全局函数中，this等于window，而当函数被作为对象的方法调用时，this等于那个对象；匿名函数的执行环境具有全局性，因此其this通常指向window。 闭包的内存泄漏闭包在IE9之前的版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML元素，那么意味着该元素将无法被销毁。","categories":[],"tags":[]},{"title":"js-object","slug":"js-object","date":"2020-02-28T12:56:40.000Z","updated":"2020-03-02T03:05:52.000Z","comments":true,"path":"2020/02/28/js-object/","link":"","permalink":"http://renwanjun.github.io/2020/02/28/js-object/","excerpt":"","text":"创建对象工厂模式工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。用函数来封装以特定接口创建对象的细节。 构造函数模式可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。","categories":[],"tags":[]},{"title":"最佳实践","slug":"the-best-coding","date":"2020-02-27T07:33:32.000Z","updated":"2020-02-28T12:56:20.000Z","comments":true,"path":"2020/02/27/the-best-coding/","link":"","permalink":"http://renwanjun.github.io/2020/02/27/the-best-coding/","excerpt":"","text":"可维护的代码保证代码性能部署代码 可维护性可理解性、直观性、可适应性、可扩展性、可调式性 代码约定形成一套JavaScript代码的书写约定。 缩进和注释可以带来更可读的代码，在未来则更容易维护。 1. 可读性可读性与代码作为文本文件的格式化方式有关。一方面是代码的 缩进，当大部分人都使用同一种缩进方式时，整个项目中的代码都会更加易于阅读；一方面是注释，通常使用若干空格而不是制表符来表示缩进，因为制表符在不同的文本编辑器中显示效果不同。 一种常见的缩进大小为4个空格 需要进行注释的地方 函数和算法每一个函数和算法都应该包含注释，描述其目的和用于完成任务缩可能使用的算法。陈述实现的假设也非常重要，如参数代表什么，函数是否有返回值。 大段代码用于完成单个任务的多行代码应该在前面放一个描述任务的注释。 复杂的算法在注释中解释如何做到，不仅可以帮助其它浏览你的代码的人，也能在下次你自己查阅代码的时候帮助理解。 Hack因为存在浏览器差异，JavaScript代码一般会包含一些hack。 2.变量和函数命名命名规则 变量名应为名词，如car。 函数名应该以动词开始，如getName()；返回布尔类型值的函数一般以is开头，如isEnable()。 变量和函数都应使用合乎逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩来缓解。 3.变量类型透明因为JS中变量是松散类型，很容易就忘记变量所应包含的数据类型。合适的命名方式可以帮助理解变量的数据类型，有三种表示数据类型的方式。 初始化","categories":[],"tags":[]},{"title":"执行环境和作用域","slug":"js-environment","date":"2020-02-25T09:11:04.000Z","updated":"2020-02-27T07:32:59.000Z","comments":true,"path":"2020/02/25/js-environment/","link":"","permalink":"http://renwanjun.github.io/2020/02/25/js-environment/","excerpt":"","text":"基本概念基本类型值：简单的数据段引用类型值：可能由多个值构成的对象传递参数：按值传递检测类型： typeof 检测基本数据类型的最佳工具instanceof 检测对象构造函数的最佳工具根据规定，所有引用类型的的值都是Object的实例 执行环境与作用域执行环境（execution context）是JavaScript中的一个重要概念。定义：执行环境定义了变量或函数有权访问的其它数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 作用域链定义：当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的前端始终都是当前执行的代码所在环境的变量对象；全局执行环境始终是作用域链中的最后一个对象。 垃圾收集机制JavaScript具有 自动垃圾收集机制 ，也就是说执行环境会负责管理代码执行过程中使用的内存。 原理：找出那些不再使用的变量，然后释放其内存。","categories":[{"name":"Web大前端","slug":"Web大前端","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript后花园","slug":"Web大前端/JavaScript后花园","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript%E5%90%8E%E8%8A%B1%E5%9B%AD/"}],"tags":[]},{"title":"JavaScript之数据类型","slug":"JavaScript之数据类型","date":"2020-02-25T02:48:05.000Z","updated":"2021-02-26T10:22:22.000Z","comments":true,"path":"2020/02/25/JavaScript之数据类型/","link":"","permalink":"http://renwanjun.github.io/2020/02/25/JavaScript%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"先来了解一些基本概念 语法：ECMAScript语法大量借鉴了C及其他类C语言的语法 区分大小写：ECMAScript中的一切都区分大小写 变量、函数名和操作符 标识符：就是指变量、函数、属性的名字，或者函数的参数。标识符由字母、数字、下弧线_或一个美元符号$组成，首字母不能是数字。推荐采用驼峰大小写格式，例如firstSecond，可与内置的函数和对象名保持一致。 严格模式：ECMAScript5引入严格模式，为JavaScript定义了一种不同的解析与执行模型。要在整个脚本中启用严格模式，在顶部添加&quot;use strict&quot;。也可在指定函数在严格模式下执行，在函数内部的上方添加这条编译指示：1234function doSomething()&#123; &quot;use strict&quot; //函数体&#125; 变量：松散类型变量，所谓松散类型变量就是可以保存任何类型的变量。换句话说，每个变量仅仅是一个用于保存值的占位符而已。我们不建议修改变量保存值类型。 数据类型五种简单数据类型: Undefined,Null,Boolean,Number和String一种复杂数据类型: Object typeof操作符typeof操作符用于检测给定变量、数值字面量的数据类型 typeof操作符返回值 可能数据类型 undefined 如果这个值未定义 boolean 如果这个值是布尔值 string 如果这个值是字符串 number 如果这个值是数值（12，NaN） object 如果这个值是对象或者是null function 如果这个值是函数 从技术角度讲，函数在ECMAScript中是对象不是一种数据类型。然而函数确实有些特殊的实行，因此通过typeof操作符区分函数和其他对象是有必要的。 Undefined值范围：只有一个特殊值undefined。情况一：使用var声明一个变量但未对其初始化时，这个变量值就是undefined。 因此没有必要把一个变量的值显示地设置成undefined 12var message;aler (message==undefined);// true 情况二：尚未定义的变量 1234var message; // 这个变量声明之后默认取得了undefined值alert(message) // &quot;undefined&quot;alert(age) // 产生错误 对于尚未声明过的变量，只能执行一项操作即实用typeof操作符检测其数据类型。（delete操作虽然不会报错，但是没有实际意义，且在strict mode下确实会报错） Null类型数值范围：只有一个特殊值null从逻辑角度看，null是一个空对象指针，而这正是使用typeof操作符检测null值会返回”object”的原因。 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其它值。如此只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用。 实际上，undefined值是派生自null值的，因此： 1alert(null==undefined); // true 尽管如此，两者用途完全不同不可混淆。 Boolean类型值范围：true 和 false 注意：Boolean类型的字面值true和false是区分大小的，也就是TRUE和FALSE都不是Boolean值，只是关键字。 转型函数：Boolean()ECMAScript中所有类型的值都有与这两个Boolean值等价的值。 数据类型 转换为true的值 转换为false的值 Boolean true false Undefined n/a [^1] undefined Null null String 任何非空字符串 “”空字符串 Number 任何非零数值 0和NaN Object 任何对象 null [^1]:n/a(或N/A),是not application的缩写，意思是“不适用” 这些转换规则对理解 流控制语句 自动执行相应的Boolean转换非常重要。 Number","categories":[{"name":"Web大前端","slug":"Web大前端","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript后花园","slug":"Web大前端/JavaScript后花园","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript%E5%90%8E%E8%8A%B1%E5%9B%AD/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://renwanjun.github.io/tags/JavaScript/"}],"author":"renwanjun"},{"title":"Homebrew更新太慢，切换源","slug":"Homebrew","date":"2020-02-15T07:25:00.000Z","updated":"2020-02-15T11:44:01.000Z","comments":true,"path":"2020/02/15/Homebrew/","link":"","permalink":"http://renwanjun.github.io/2020/02/15/Homebrew/","excerpt":"","text":"执行$ brew update太慢，更换Homebrew的更新源。 更新源的选择平时我们执行brew命令安装软件的时候，跟以下3个仓库地址有关： brew.git homebrew-core.git homebrew-bottles 默认官方的更新源都是存放在GitHub上的，这也是中国大陆用户访问缓慢的原因，一般来说我们会更倾向选择国内提供的更新源，在此推荐中国科大以及清华大学提供的更新源,常见的还有阿里巴巴提供的更新源。 GitHub源 origin https://github.com/Homebrew/brew.git origin https://github.com/Homebrew/homebrew-core.git origin https://github.com/Homebrew/homebrew-bottles 中国科大源 origin https://mirrors.ustc.edu.cn/brew.git origin https://mirrors.ustc.edu.cn/homebrew-core.git origin https://mirrors.ustc.edu.cn/homebrew-bottles 清华大学源 origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-bottles 阿里巴巴源 origin https://mirrors.aliyun.com/homebrew/brew.git origin https://mirrors.aliyun.com/homebrew/homebrew-core.git origin https://mirrors.aliyun.com/homebrew/homebrew-bottles 替换更新源以中国科大源为例： 1234567891011121314151617# 替换brew.git:$ cd &quot;$(brew --repo)&quot;# 中国科大:$ git remote set-url origin https://mirrors.ustc.edu.cn/brew.git# 替换homebrew-core.git:$ cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;# 中国科大:$ git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git# 替换homebrew-bottles:# 中国科大:$ echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profile$ source ~/.bash_profile# 应用生效:$ brew update 在更新homebrew-bottles的访问地址时，与MacOS系统的shell版本有关。查看shell版本 1$ echo $SHELl 如果你的输出结果是 /bin/zsh，参考zsh 终端操作方式 12$ echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.zshrc$ source ~/.zshrc 如果你的输出结果是 /bin/bash，参考bash 终端操作方式 12$ echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profile$ source ~/.bash_profile 如果之前折腾过不少导致你的Homebrew有点问题，那么可以尝试使用如下方案： 123456789101112131415# 诊断Homebrew的问题:$ brew doctor# 重置brew.git设置:$ cd &quot;$(brew --repo)&quot;$ git fetch$ git reset --hard origin/master# homebrew-core.git同理:$ cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;$ git fetch$ git reset --hard origin/master# 应用生效:$ brew update 重置更新源后有时候也有换回官方GitHub源的需求 1234567# 重置brew.git:$ cd &quot;$(brew --repo)&quot;$ git remote set-url origin https://github.com/Homebrew/brew.git# 重置homebrew-core.git:$ cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;$ git remote set-url origin https://github.com/Homebrew/homebrew-core.git 后记1.完成更新源的更换后，我们可以使用$ brew upgrade将现有的软件进行更新至最新版本，这样便能很直接的看出速度上的变化了。最后不要忘记$ brew cleanup将旧有的软件安装包进行清理 2.在更新源的有时候可能会遇到上一次更新进程还没有结束的问题： 12Error: Another active Homebrew update process is already in progress.Please wait for it to finish or terminate it to continue. 使用以下命令解除homwbrew进程锁定 1$ rm -rf /usr/local/var/homebrew/locks 解除锁定后再次更新 3.关闭brew每次执行命令时的自动更新，执行如下命令 1export HOMEBREW_NO_AUTO_UPDATE=true ps:如果速度还是很慢试试这个方法切换git代理","categories":[{"name":"Tool","slug":"Tool","permalink":"http://renwanjun.github.io/categories/Tool/"}],"tags":[],"author":"renwanjun"},{"title":"考研英语一","slug":"考研英语一","date":"2020-02-11T11:55:00.000Z","updated":"2020-02-11T11:55:27.000Z","comments":true,"path":"2020/02/11/考研英语一/","link":"","permalink":"http://renwanjun.github.io/2020/02/11/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E4%B8%80/","excerpt":"","text":"","categories":[{"name":"2021考研","slug":"2021考研","permalink":"http://renwanjun.github.io/categories/2021%E8%80%83%E7%A0%94/"}],"tags":[{"name":"英语一","slug":"英语一","permalink":"http://renwanjun.github.io/tags/%E8%8B%B1%E8%AF%AD%E4%B8%80/"}],"author":"renwanjun"},{"title":"2021考研 目标院校和专业","slug":"2021考研-目标院校和专业","date":"2020-02-11T11:30:00.000Z","updated":"2020-02-11T11:54:43.000Z","comments":true,"path":"2020/02/11/2021考研-目标院校和专业/","link":"","permalink":"http://renwanjun.github.io/2020/02/11/2021%E8%80%83%E7%A0%94-%E7%9B%AE%E6%A0%87%E9%99%A2%E6%A0%A1%E5%92%8C%E4%B8%93%E4%B8%9A/","excerpt":"","text":"目标专业：计算机科学与技术 或者 软件工程目标院校：上海交通大学 985院校 专业硕士","categories":[{"name":"2021考研","slug":"2021考研","permalink":"http://renwanjun.github.io/categories/2021%E8%80%83%E7%A0%94/"}],"tags":[],"author":"renwanjun"},{"title":"大前端概述","slug":"web-summary","date":"2020-02-11T02:13:19.000Z","updated":"2020-02-11T02:55:17.000Z","comments":true,"path":"2020/02/11/web-summary/","link":"","permalink":"http://renwanjun.github.io/2020/02/11/web-summary/","excerpt":"","text":"前端开发工程师必须掌握的三种技能：描述网页内容的HTML、描述网页的样式CSS以及描述网页行为的JavaScript。 前端面试题","categories":[{"name":"Web大前端","slug":"Web大前端","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[]},{"title":"Web大前端","slug":"Web大前端","date":"2020-02-11T01:16:59.000Z","updated":"2020-02-11T02:14:09.000Z","comments":true,"path":"2020/02/11/Web大前端/","link":"","permalink":"http://renwanjun.github.io/2020/02/11/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/","excerpt":"","text":"前端开发工程师必须掌握的三种技能：描述网页内容的","categories":[],"tags":[],"author":"renwanjun"},{"title":"Hexo+GitHub快速搭建博客","slug":"tutorial-hexo-github","date":"2020-02-10T14:17:52.000Z","updated":"2020-03-16T05:00:50.000Z","comments":true,"path":"2020/02/10/tutorial-hexo-github/","link":"","permalink":"http://renwanjun.github.io/2020/02/10/tutorial-hexo-github/","excerpt":"","text":"在学习搭建博客的过程中参考的资料和遇到的问题，大神们的教程让我受益匪浅，特别收集了这些参考教程希望给大家带去方便。 Hexo+GitHub参考资料快速搭建基于Hexo和Github搭建博客——超级详细，一步一步手把手式教学 Hexo写博客和Hexo Admin管理——介绍了Hexo Admin插件的使用方式 hexo官网——Hexo官方网站 切换主题去哪里寻找好看的主题有哪些好看的Hexo主题——推荐好看的Hexo主题 hexo主题库——Hexo的主题😢 如何切换git clone 博客搭建深入系列–TODO在Hexo主题中新添加resume布局Hexo 个人博客 SEO 优化Hexo 搭建个人博客Hexo博客实现首页和子页面不同layout布局 可能遇见的问题1.GitHub Pages 404 问题可能原因：1.浏览器存在缓存 2.Hexo设置语言不生效Hexo设置中文不生效 3.设置hexo-admin出错Error: Config value “admin.deployCommand” not found 4.vi命令写入内容vi命令 5.如何管理源文件和静态文件在master分支上发布静态网站，在hexo分支上保存源文件利用Hexo在多台电脑上提交和更新github pages博客","categories":[{"name":"Web大前端","slug":"Web大前端","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"Tool","slug":"Web大前端/Tool","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/Tool/"}],"tags":[]},{"title":"JavaScript之this到底是什么","slug":"js-this","date":"2020-02-10T13:19:10.000Z","updated":"2020-03-30T05:41:30.000Z","comments":true,"path":"2020/02/10/js-this/","link":"","permalink":"http://renwanjun.github.io/2020/02/10/js-this/","excerpt":"","text":"前言this对象是在运行时基于函数的执行环境绑定的；在全局环境中,this等于window,而当函数被当作某个对象的方法调用时，this指向这个对象。而匿名函数执行时this通常都是指向window,除非显示使用call、apply、bind绑定执行对象。 JavaScript的运行环境浏览器环境Node环境 顶层对象浏览器环境——window对象Node环境——global对象 全局变量和顶层对象属性的分离在ES5中，顶层对象的属性和全局变量是等价的；ES6为了改变这一点，规定var命令和function命令声明的全局变量依旧是顶层对象的属性；另一方面，let命令、const命令、class命令声明的全局变量不属于顶层对象的属性。 关于this的来源每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 全局函数中的this对象的方法中的this闭包中的this箭头函数中的this绑定this","categories":[{"name":"Web大前端","slug":"Web大前端","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript后花园","slug":"Web大前端/JavaScript后花园","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript%E5%90%8E%E8%8A%B1%E5%9B%AD/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://renwanjun.github.io/tags/JavaScript/"}]},{"title":"盒尺寸四大家族","slug":"css-box","date":"2020-02-10T13:14:48.000Z","updated":"2020-02-11T02:55:48.000Z","comments":true,"path":"2020/02/10/css-box/","link":"","permalink":"http://renwanjun.github.io/2020/02/10/css-box/","excerpt":"","text":"","categories":[{"name":"Web大前端","slug":"Web大前端","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"CSS世界","slug":"Web大前端/CSS世界","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/CSS%E4%B8%96%E7%95%8C/"}],"tags":[{"name":"css","slug":"css","permalink":"http://renwanjun.github.io/tags/css/"}]},{"title":"流、元素与基本尺寸","slug":"css-basic","date":"2020-02-10T13:13:27.000Z","updated":"2020-02-11T02:55:53.000Z","comments":true,"path":"2020/02/10/css-basic/","link":"","permalink":"http://renwanjun.github.io/2020/02/10/css-basic/","excerpt":"","text":"jiebenss","categories":[{"name":"Web大前端","slug":"Web大前端","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"CSS世界","slug":"Web大前端/CSS世界","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/CSS%E4%B8%96%E7%95%8C/"}],"tags":[]}],"categories":[{"name":"Tool","slug":"Tool","permalink":"http://renwanjun.github.io/categories/Tool/"},{"name":"Web大前端","slug":"Web大前端","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript后花园","slug":"Web大前端/JavaScript后花园","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/JavaScript%E5%90%8E%E8%8A%B1%E5%9B%AD/"},{"name":"2021考研","slug":"2021考研","permalink":"http://renwanjun.github.io/categories/2021%E8%80%83%E7%A0%94/"},{"name":"Tool","slug":"Web大前端/Tool","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/Tool/"},{"name":"CSS世界","slug":"Web大前端/CSS世界","permalink":"http://renwanjun.github.io/categories/Web%E5%A4%A7%E5%89%8D%E7%AB%AF/CSS%E4%B8%96%E7%95%8C/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://renwanjun.github.io/tags/npm/"},{"name":"command","slug":"command","permalink":"http://renwanjun.github.io/tags/command/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://renwanjun.github.io/tags/JavaScript/"},{"name":"英语一","slug":"英语一","permalink":"http://renwanjun.github.io/tags/%E8%8B%B1%E8%AF%AD%E4%B8%80/"},{"name":"css","slug":"css","permalink":"http://renwanjun.github.io/tags/css/"}]}